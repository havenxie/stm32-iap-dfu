; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\hw_config.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\CMSIS\Include -ID:\Keil5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL --omf_browse=.\stm3210b-eval\hw_config.crf ..\src\hw_config.c]
                          THUMB

                          AREA ||i.DFU_Button_Config||, CODE, READONLY, ALIGN=1

                  DFU_Button_Config PROC
;;;253    *******************************************************************************/
;;;254    void DFU_Button_Config(void)
000000  2100              MOVS     r1,#0
;;;255    {  
;;;256    #if defined (USE_STM32L152_EVAL)
;;;257      /* Configure "DFU enter" button */
;;;258      STM_EVAL_PBInit(Button_UP, Mode_GPIO);  
;;;259    #else  
;;;260      /* Configure "DFU enter" button */
;;;261      STM_EVAL_PBInit(Button_KEY, Mode_GPIO);
000002  2002              MOVS     r0,#2
000004  f7ffbffe          B.W      STM_EVAL_PBInit
;;;262    #endif /* USE_STM32L152_EVAL */
;;;263    }
;;;264    
                          ENDP


                          AREA ||i.DFU_Button_Read||, CODE, READONLY, ALIGN=1

                  DFU_Button_Read PROC
;;;271    *******************************************************************************/
;;;272    uint8_t DFU_Button_Read (void)
000000  b510              PUSH     {r4,lr}
;;;273    {
;;;274    #if defined (USE_STM32L152_EVAL) 
;;;275      return STM_EVAL_PBGetState(Button_UP); 
;;;276    #elif defined (USE_STM32L152D_EVAL) 
;;;277      return !STM_EVAL_PBGetState(Button_KEY); 
;;;278    #else    
;;;279      return STM_EVAL_PBGetState(Button_KEY);  
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       STM_EVAL_PBGetState
000008  b2c0              UXTB     r0,r0
;;;280    #endif /* USE_STM32L152_EVAL */  
;;;281    }
00000a  bd10              POP      {r4,pc}
;;;282    
                          ENDP


                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;185    *******************************************************************************/
;;;186    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L3.8|
;;;187    {
;;;188      /* Set the device state to suspend */
;;;189      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;190    }
000006  4770              BX       lr
;;;191    
                          ENDP

                  |L3.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;360    *******************************************************************************/
;;;361    void Get_SerialNum(void)
000000  480a              LDR      r0,|L4.44|
;;;362    {
000002  b510              PUSH     {r4,lr}
;;;363      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;364    
;;;365      Device_Serial0 = *(uint32_t*)ID1;
;;;366      Device_Serial1 = *(uint32_t*)ID2;
000004  6801              LDR      r1,[r0,#0]
000006  1d00              ADDS     r0,r0,#4
;;;367      Device_Serial2 = *(uint32_t*)ID3;   
000008  6804              LDR      r4,[r0,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
;;;368    
;;;369      Device_Serial0 += Device_Serial2;
00000e  1808              ADDS     r0,r1,r0
000010  d00b              BEQ      |L4.42|
;;;370    
;;;371      if (Device_Serial0 != 0)
;;;372      {
;;;373        IntToUnicode (Device_Serial0, &DFU_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L4.48|
000016  f7fffffe          BL       IntToUnicode
;;;374        IntToUnicode (Device_Serial1, &DFU_StringSerial[18], 4);
00001a  4905              LDR      r1,|L4.48|
00001c  4620              MOV      r0,r4
00001e  2204              MOVS     r2,#4
000020  e8bd4010          POP      {r4,lr}
000024  3110              ADDS     r1,r1,#0x10
000026  f7ffbffe          B.W      IntToUnicode
                  |L4.42|
;;;375      }
;;;376    }
00002a  bd10              POP      {r4,pc}
;;;377    
                          ENDP

                  |L4.44|
                          DCD      0x1ffff7e8
                  |L4.48|
                          DCD      DFU_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;384    *******************************************************************************/
;;;385    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;386    {
;;;387      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;388      
;;;389      for( idx = 0 ; idx < len ; idx ++)
;;;390      {
;;;391        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;392        {
;;;393          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;394        }
;;;395        else
;;;396        {
;;;397          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L5.50|
00000e  bf00              NOP                            ;391
                  |L5.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;391
000014  d902              BLS      |L5.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;393
00001a  e001              B        |L5.32|
                  |L5.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L5.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;398        }
;;;399        
;;;400        value = value << 4;
;;;401        
;;;402        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;400
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;389
                  |L5.50|
000032  4293              CMP      r3,r2                 ;389
000034  d3ec              BCC      |L5.16|
;;;403      }
;;;404    }
000036  bdf0              POP      {r4-r7,pc}
;;;405    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;198    *******************************************************************************/
;;;199    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L6.20|
;;;200    {
;;;201      DEVICE_INFO *pInfo = &Device_Info;
;;;202    
;;;203      /* Set the device state to the correct state */
;;;204      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;205      {
;;;206        /* Device configured */
;;;207        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L6.24|
000006  b109              CBZ      r1,|L6.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L6.14|
                  |L6.12|
;;;208      }
;;;209      else
;;;210      {
;;;211        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L6.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;212      }
;;;213      /*Enable SystemCoreClock*/
;;;214      SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;215    }
;;;216    
                          ENDP

                  |L6.20|
                          DCD      Device_Info
                  |L6.24|
                          DCD      bDeviceState

                          AREA ||i.Reset_Device||, CODE, READONLY, ALIGN=2

                  Reset_Device PROC
;;;347    *******************************************************************************/
;;;348    void Reset_Device(void)
000000  2000              MOVS     r0,#0
;;;349    {
;;;350      USB_Cable_Config(DISABLE);
000002  f7fffffe          BL       USB_Cable_Config
000006  f3bf8f4f          DSB      
00000a  4805              LDR      r0,|L7.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  4a05              LDR      r2,|L7.36|
000010  f40161e0          AND      r1,r1,#0x700
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
000018  f3bf8f4f          DSB      
                  |L7.28|
00001c  e7fe              B        |L7.28|
;;;351      NVIC_SystemReset();
;;;352    }
;;;353    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0xe000ed0c
                  |L7.36|
                          DCD      0x05fa0004

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;54     *******************************************************************************/
;;;55     void Set_System(void)
000000  b538              PUSH     {r3-r5,lr}
;;;56     {
;;;57     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined (STM32L1XX_MD_PLUS)
;;;58       GPIO_InitTypeDef GPIO_InitStructure;
;;;59     #endif /* STM32L1XX_XD*/
;;;60       
;;;61     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;62       GPIO_InitTypeDef  GPIO_InitStructure;
;;;63     #endif /* USB_USE_EXTERNAL_PULLUP */ 
;;;64       
;;;65       /*!< At this stage the microcontroller clock setting is already configured, 
;;;66            this is done through SystemInit() function which is called from startup
;;;67            file (startup_stm32f10x_xx.s) before to branch to application main.
;;;68            To reconfigure the default setting of SystemInit() function, refer to
;;;69            system_stm32f10x.c file
;;;70          */ 
;;;71       
;;;72     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;73       /* Enable the SYSCFG module clock */
;;;74       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;75     #endif /* STM32L1XX_XD */ 
;;;76        
;;;77     FLASH_Unlock();
000002  f7fffffe          BL       FLASH_Unlock
;;;78       
;;;79     #ifdef USE_STM3210E_EVAL
;;;80       /* Enable the FSMC Clock */
;;;81       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
;;;82     #endif /* USE_STM3210E_EVAL */
;;;83     #if defined (USE_STM3210E_EVAL)
;;;84       /* Enable the FSMC Clock */
;;;85       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
;;;86     #endif /* USE_STM3210E_EVAL */
;;;87         
;;;88     #if defined(STM32F37X) || defined(STM32F30X)
;;;89       /* Enable the USB disconnect GPIO clock */
;;;90       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;91     
;;;92      /*Set PA11,12 as IN - USB_DM,DP*/
;;;93       
;;;94       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;95       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;96       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;97       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;98       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;99       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;100      GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;101        
;;;102      /*SET PA11,12 for USB: USB_DM,DP*/
;;;103      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;104      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;105     
;;;106      /* USB_DISCONNECT used as USB pull-up */
;;;107      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;108      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;109      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;110      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;111      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;112      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;113      
;;;114     /*Output low level on USB_Disconnect Pin to enable 1.5k ohm pull-up resistor*/
;;;115      GPIO_WriteBit(USB_DISCONNECT, USB_DISCONNECT_PIN, Bit_RESET);
;;;116    
;;;117    #endif /* STM32F37X && STM32F30X */
;;;118    
;;;119    #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)  && !defined(STM32F37X) && !defined(STM32F30X)
;;;120      /* Enable "DISCONNECT" GPIO clock */
;;;121      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
000006  2101              MOVS     r1,#1
000008  2020              MOVS     r0,#0x20
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;122    
;;;123      /* Configure USB pull-up */
;;;124      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
00000e  f44f7000          MOV      r0,#0x200
000012  f8ad0000          STRH     r0,[sp,#0]
;;;125      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;126      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
00001c  2014              MOVS     r0,#0x14
00001e  f88d0003          STRB     r0,[sp,#3]
;;;127      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
000022  4669              MOV      r1,sp
000024  480c              LDR      r0,|L8.88|
000026  f7fffffe          BL       GPIO_Init
;;;128    
;;;129      /* Disable the USB connection till initialization phase end */  
;;;130      USB_Cable_Config(DISABLE);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       USB_Cable_Config
;;;131    #endif /* STM32L1XX_XD */
;;;132    
;;;133    #if defined(USB_USE_EXTERNAL_PULLUP)
;;;134      /* Enable the USB disconnect GPIO clock */
;;;135      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;136    
;;;137      /* USB_DISCONNECT used as USB pull-up */
;;;138      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;139      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;140      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;141      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;142      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;143      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;144    #endif /* USB_USE_EXTERNAL_PULLUP */
;;;145      
;;;146      /* Init the media interface */
;;;147      MAL_Init();
000030  f7fffffe          BL       MAL_Init
;;;148      USB_Cable_Config(ENABLE);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       USB_Cable_Config
;;;149      
;;;150          /* Configure the EXTI line 18 connected internally to the USB IP */
;;;151      EXTI_ClearITPendingBit(EXTI_Line18);
00003a  f44f2480          MOV      r4,#0x40000
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       EXTI_ClearITPendingBit
;;;152      EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
000044  4905              LDR      r1,|L8.92|
;;;153      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000046  2008              MOVS     r0,#8
000048  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
00004a  7148              STRB     r0,[r1,#5]
;;;154      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00004c  2001              MOVS     r0,#1
00004e  7188              STRB     r0,[r1,#6]
;;;155      EXTI_Init(&EXTI_InitStructure);
000050  4608              MOV      r0,r1
000052  f7fffffe          BL       EXTI_Init
;;;156    }
000056  bd38              POP      {r3-r5,pc}
;;;157    
                          ENDP

                  |L8.88|
                          DCD      0x40011400
                  |L8.92|
                          DCD      ||area_number.15||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;164    *******************************************************************************/
;;;165    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;168      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;169       
;;;170    #else 
;;;171      /* Select USBCLK source */
;;;172      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;173      
;;;174      /* Enable the USB clock */
;;;175      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;176    #endif /* STM32L1XX_MD */
;;;177    }
;;;178    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;223    *******************************************************************************/
;;;224    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;225    {
;;;226    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;227      if (NewState != DISABLE)
;;;228      {
;;;229        STM32L15_USB_CONNECT;
;;;230      }
;;;231      else
;;;232      {
;;;233        STM32L15_USB_DISCONNECT;
;;;234      }  
;;;235    #else 
;;;236      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;237      {
;;;238        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000004  f44f7100          MOV      r1,#0x200
;;;239      }
;;;240      else
;;;241      {
;;;242        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L10.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L10.16|
000010  f7ffbffe          B.W      GPIO_SetBits
;;;243      }
;;;244    #endif /* STM32L1XX_XD */
;;;245    }
;;;246    
                          ENDP

                  |L10.20|
                          DCD      0x40011400

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;289    *******************************************************************************/
;;;290    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;291    {
;;;292      NVIC_InitTypeDef NVIC_InitStructure;
;;;293    
;;;294      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;295      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;296      
;;;297    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;298      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;299      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;300      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;301      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;302      NVIC_Init(&NVIC_InitStructure);
;;;303      
;;;304        /* Enable the USB Wake-up interrupt */
;;;305      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
;;;306      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;307      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;308      NVIC_Init(&NVIC_InitStructure);
;;;309      
;;;310    #elif defined(STM32F37X)
;;;311      /* Enable the USB interrupt */
;;;312      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;313      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;314      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;315      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;316      NVIC_Init(&NVIC_InitStructure);
;;;317      
;;;318      /* Enable the USB Wake-up interrupt */
;;;319      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;320      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;321      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;322      NVIC_Init(&NVIC_InitStructure);
;;;323      
;;;324    #else 
;;;325      /* Enable the USB interrupt */
;;;326      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;327      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;328      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;329      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;330      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;331      
;;;332        /* Enable the USB Wake-up interrupt */
;;;333      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;334      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;335      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d5003          STRB     r5,[sp,#3]
;;;336      NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;337      
;;;338    #endif /* STM32L1XX_XD */
;;;339    }
00003c  bd38              POP      {r3-r5,pc}
;;;340    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 129 "D:\\Keil5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 144
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
