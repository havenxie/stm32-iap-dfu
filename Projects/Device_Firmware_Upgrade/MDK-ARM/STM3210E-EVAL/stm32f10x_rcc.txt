; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\stm32f10x_rcc.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\CMSIS\Include -ID:\Keil5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\stm32f10x_rcc.crf ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;771      */
;;;772    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  4a03              LDR      r2,|L1.16|
;;;773    {
;;;774      uint32_t tmpreg = 0;
;;;775      /* Check the parameters */
;;;776      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;777      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;778      /* Clear ADCPRE[1:0] bits */
;;;779      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000004  f4214140          BIC      r1,r1,#0xc000
;;;780      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;781      tmpreg |= RCC_PCLK2;
000008  4301              ORRS     r1,r1,r0
;;;782      /* Store the new value */
;;;783      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;784    }
00000c  4770              BX       lr
;;;785    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1069     */
;;;1070   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1071   {
;;;1072     /* Check the parameters */
;;;1073     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1074     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1075   
;;;1076     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1077     {
;;;1078       RCC->AHBENR |= RCC_AHBPeriph;
;;;1079     }
;;;1080     else
;;;1081     {
;;;1082       RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1078
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6151              STR      r1,[r2,#0x14]         ;1078
;;;1083     }
;;;1084   }
000010  4770              BX       lr
;;;1085   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1131     */
;;;1132   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1133   {
;;;1134     /* Check the parameters */
;;;1135     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1136     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1137     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1138     {
;;;1139       RCC->APB1ENR |= RCC_APB1Periph;
;;;1140     }
;;;1141     else
;;;1142     {
;;;1143       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1139
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;1139
;;;1144     }
;;;1145   }
000010  4770              BX       lr
;;;1146   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1221     */
;;;1222   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1223   {
;;;1224     /* Check the parameters */
;;;1225     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1226     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1227     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1228     {
;;;1229       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1230     }
;;;1231     else
;;;1232     {
;;;1233       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1229
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6111              STR      r1,[r2,#0x10]         ;1229
;;;1234     }
;;;1235   }
000010  4770              BX       lr
;;;1236   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1100     */
;;;1101   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1102   {
;;;1103     /* Check the parameters */
;;;1104     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1105     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1106     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1107     {
;;;1108       RCC->APB2ENR |= RCC_APB2Periph;
;;;1109     }
;;;1110     else
;;;1111     {
;;;1112       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1108
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6191              STR      r1,[r2,#0x18]         ;1108
;;;1113     }
;;;1114   }
000010  4770              BX       lr
;;;1115   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1190     */
;;;1191   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1192   {
;;;1193     /* Check the parameters */
;;;1194     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1195     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1196     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1197     {
;;;1198       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1199     }
;;;1200     else
;;;1201     {
;;;1202       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  68d1              LDR      r1,[r2,#0xc]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1198
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  60d1              STR      r1,[r2,#0xc]          ;1198
;;;1203     }
;;;1204   }
000010  4770              BX       lr
;;;1205   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;339      */
;;;340    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L7.16|
;;;341    {
;;;342      uint32_t tmpreg = 0;
;;;343      /* Check the parameters */
;;;344      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;345      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;346      /* Clear HSITRIM[4:0] bits */
;;;347      tmpreg &= CR_HSITRIM_Mask;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;348      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;349      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;350      /* Store the new value */
;;;351      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;352    }
00000e  4770              BX       lr
;;;353    
                          ENDP

                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1242     */
;;;1243   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;1244   {
;;;1245     /* Check the parameters */
;;;1246     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1247     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1248   }
000004  4770              BX       lr
;;;1249   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1376     */
;;;1377   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L9.12|
;;;1378   {
;;;1379     /* Set RMVF bit to clear the reset flags */
;;;1380     RCC->CSR |= CSR_RMVF_Set;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1381   }
00000a  4770              BX       lr
;;;1382   
                          ENDP

                  |L9.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1453     */
;;;1454   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;1455   {
;;;1456     /* Check the parameters */
;;;1457     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1458   
;;;1459     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1460        pending bits */
;;;1461     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1462   }
000004  4770              BX       lr
;;;1463   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;1255     */
;;;1256   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;1257   {
;;;1258     /* Check the parameters */
;;;1259     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1260     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;1261   }
000004  4770              BX       lr
;;;1262   
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;222      */
;;;223    void RCC_DeInit(void)
000000  480c              LDR      r0,|L12.52|
;;;224    {
;;;225      /* Set HSION bit */
;;;226      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;227    
;;;228      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;229    #ifndef STM32F10X_CL
;;;230      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0a              LDR      r2,|L12.56|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;231    #else
;;;232      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;233    #endif /* STM32F10X_CL */   
;;;234      
;;;235      /* Reset HSEON, CSSON and PLLON bits */
;;;236      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4a09              LDR      r2,|L12.60|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;237    
;;;238      /* Reset HSEBYP bit */
;;;239      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;240    
;;;241      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;242      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000022  6841              LDR      r1,[r0,#4]
000024  f42101fe          BIC      r1,r1,#0x7f0000
000028  6041              STR      r1,[r0,#4]
;;;243    
;;;244    #ifdef STM32F10X_CL
;;;245      /* Reset PLL2ON and PLL3ON bits */
;;;246      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;247    
;;;248      /* Disable all interrupts and clear pending bits  */
;;;249      RCC->CIR = 0x00FF0000;
;;;250    
;;;251      /* Reset CFGR2 register */
;;;252      RCC->CFGR2 = 0x00000000;
;;;253    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;254      /* Disable all interrupts and clear pending bits  */
;;;255      RCC->CIR = 0x009F0000;
;;;256    
;;;257      /* Reset CFGR2 register */
;;;258      RCC->CFGR2 = 0x00000000;      
;;;259    #else
;;;260      /* Disable all interrupts and clear pending bits  */
;;;261      RCC->CIR = 0x009F0000;
00002a  f44f011f          MOV      r1,#0x9f0000
00002e  6081              STR      r1,[r0,#8]
;;;262    #endif /* STM32F10X_CL */
;;;263    
;;;264    }
000030  4770              BX       lr
;;;265    
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      0x40021000
                  |L12.56|
                          DCD      0xf8ff0000
                  |L12.60|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;913      */
;;;914    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b530              PUSH     {r4,r5,lr}
;;;915    {
;;;916      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;917    
;;;918    #ifdef  STM32F10X_CL
;;;919      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;920    #endif /* STM32F10X_CL */
;;;921    
;;;922    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;923      uint32_t prediv1factor = 0;
;;;924    #endif
;;;925        
;;;926      /* Get SYSCLK source -------------------------------------------------------*/
;;;927      tmp = RCC->CFGR & CFGR_SWS_Mask;
000002  491f              LDR      r1,|L13.128|
000004  684a              LDR      r2,[r1,#4]
000006  f012030c          ANDS     r3,r2,#0xc
;;;928      
;;;929      switch (tmp)
;;;930      {
;;;931        case 0x00:  /* HSI used as system clock */
;;;932          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00000a  4a1e              LDR      r2,|L13.132|
00000c  d003              BEQ      |L13.22|
00000e  2b04              CMP      r3,#4                 ;929
000010  d001              BEQ      |L13.22|
000012  2b08              CMP      r3,#8                 ;929
000014  d021              BEQ      |L13.90|
                  |L13.22|
;;;933          break;
;;;934        case 0x04:  /* HSE used as system clock */
;;;935          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
;;;936          break;
;;;937        case 0x08:  /* PLL used as system clock */
;;;938    
;;;939          /* Get PLL clock source and multiplication factor ----------------------*/
;;;940          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
;;;941          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
;;;942          
;;;943    #ifndef STM32F10X_CL      
;;;944          pllmull = ( pllmull >> 18) + 2;
;;;945          
;;;946          if (pllsource == 0x00)
;;;947          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;948            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;949          }
;;;950          else
;;;951          {
;;;952     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;953           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;954           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;955           RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
;;;956     #else
;;;957            /* HSE selected as PLL clock entry */
;;;958            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
;;;959            {/* HSE oscillator clock divided by 2 */
;;;960              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
;;;961            }
;;;962            else
;;;963            {
;;;964              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
;;;965            }
;;;966     #endif
;;;967          }
;;;968    #else
;;;969          pllmull = pllmull >> 18;
;;;970          
;;;971          if (pllmull != 0x0D)
;;;972          {
;;;973             pllmull += 2;
;;;974          }
;;;975          else
;;;976          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;977            pllmull = 13 / 2; 
;;;978          }
;;;979                
;;;980          if (pllsource == 0x00)
;;;981          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;982            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;983          }
;;;984          else
;;;985          {/* PREDIV1 selected as PLL clock entry */
;;;986            
;;;987            /* Get PREDIV1 clock source and division factor */
;;;988            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;989            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;990            
;;;991            if (prediv1source == 0)
;;;992            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;993              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
;;;994            }
;;;995            else
;;;996            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;997              
;;;998              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;999              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;1000             pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;1001             RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;1002           }
;;;1003         }
;;;1004   #endif /* STM32F10X_CL */ 
;;;1005         break;
;;;1006   
;;;1007       default:
;;;1008         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;1009         break;
;;;1010     }
;;;1011   
;;;1012     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1013     /* Get HCLK prescaler */
;;;1014     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
000016  6002              STR      r2,[r0,#0]
000018  684a              LDR      r2,[r1,#4]
;;;1015     tmp = tmp >> 4;
;;;1016     presc = APBAHBPrescTable[tmp];
;;;1017     /* HCLK clock frequency */
;;;1018     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;1019     /* Get PCLK1 prescaler */
;;;1020     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
;;;1021     tmp = tmp >> 8;
;;;1022     presc = APBAHBPrescTable[tmp];
;;;1023     /* PCLK1 clock frequency */
;;;1024     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1025     /* Get PCLK2 prescaler */
;;;1026     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
;;;1027     tmp = tmp >> 11;
;;;1028     presc = APBAHBPrescTable[tmp];
;;;1029     /* PCLK2 clock frequency */
;;;1030     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1031     /* Get ADCCLK prescaler */
;;;1032     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
;;;1033     tmp = tmp >> 14;
;;;1034     presc = ADCPrescTable[tmp];
;;;1035     /* ADCCLK clock frequency */
;;;1036     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
;;;1037   }
00001a  230f              MOVS     r3,#0xf
00001c  4c1a              LDR      r4,|L13.136|
00001e  ea031212          AND      r2,r3,r2,LSR #4
000022  5ca3              LDRB     r3,[r4,r2]            ;1016
000024  6802              LDR      r2,[r0,#0]            ;1018
000026  40da              LSRS     r2,r2,r3              ;1018
000028  6042              STR      r2,[r0,#4]            ;1020
00002a  684b              LDR      r3,[r1,#4]            ;1020
00002c  2507              MOVS     r5,#7
00002e  ea052313          AND      r3,r5,r3,LSR #8
000032  5ce3              LDRB     r3,[r4,r3]            ;1022
000034  fa22f303          LSR      r3,r2,r3              ;1024
000038  6083              STR      r3,[r0,#8]            ;1026
00003a  684b              LDR      r3,[r1,#4]            ;1026
00003c  ea0523d3          AND      r3,r5,r3,LSR #11
000040  5ce3              LDRB     r3,[r4,r3]            ;1028
000042  40da              LSRS     r2,r2,r3              ;1030
000044  60c2              STR      r2,[r0,#0xc]          ;1032
000046  6849              LDR      r1,[r1,#4]            ;1032
000048  2303              MOVS     r3,#3
00004a  ea033191          AND      r1,r3,r1,LSR #14
00004e  1f23              SUBS     r3,r4,#4              ;1034
000050  5c59              LDRB     r1,[r3,r1]            ;1034
000052  fbb2f1f1          UDIV     r1,r2,r1              ;1036
000056  6101              STR      r1,[r0,#0x10]         ;1036
000058  bd30              POP      {r4,r5,pc}
                  |L13.90|
00005a  684a              LDR      r2,[r1,#4]            ;940
00005c  684b              LDR      r3,[r1,#4]            ;941
00005e  f4021270          AND      r2,r2,#0x3c0000       ;940
000062  f04f0402          MOV      r4,#2                 ;944
000066  f4133f80          TST      r3,#0x10000           ;941
00006a  eb044292          ADD      r2,r4,r2,LSR #18      ;944
00006e  d002              BEQ      |L13.118|
000070  684b              LDR      r3,[r1,#4]            ;958
000072  039b              LSLS     r3,r3,#14             ;958
000074  d501              BPL      |L13.122|
                  |L13.118|
000076  4b05              LDR      r3,|L13.140|
000078  e000              B        |L13.124|
                  |L13.122|
00007a  4b02              LDR      r3,|L13.132|
                  |L13.124|
00007c  435a              MULS     r2,r3,r2              ;960
00007e  e7ca              B        |L13.22|
;;;1038   
                          ENDP

                  |L13.128|
                          DCD      0x40021000
                  |L13.132|
                          DCD      0x007a1200
                  |L13.136|
                          DCD      ||.data||+0x4
                  |L13.140|
                          DCD      0x003d0900

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1331     */
;;;1332   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4602              MOV      r2,r0
;;;1333   {
;;;1334     uint32_t tmp = 0;
;;;1335     uint32_t statusreg = 0;
;;;1336     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1337     /* Check the parameters */
;;;1338     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1339   
;;;1340     /* Get the RCC register index */
;;;1341     tmp = RCC_FLAG >> 5;
000004  0953              LSRS     r3,r2,#5
;;;1342     if (tmp == 1)               /* The flag to check is in CR register */
;;;1343     {
;;;1344       statusreg = RCC->CR;
000006  4909              LDR      r1,|L14.44|
000008  2b01              CMP      r3,#1                 ;1342
00000a  d00b              BEQ      |L14.36|
;;;1345     }
;;;1346     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000c  2b02              CMP      r3,#2
00000e  d00b              BEQ      |L14.40|
;;;1347     {
;;;1348       statusreg = RCC->BDCR;
;;;1349     }
;;;1350     else                       /* The flag to check is in CSR register */
;;;1351     {
;;;1352       statusreg = RCC->CSR;
000010  f8d11024          LDR.W    r1,[r1,#0x24]
                  |L14.20|
;;;1353     }
;;;1354   
;;;1355     /* Get the flag position */
;;;1356     tmp = RCC_FLAG & FLAG_Mask;
000014  f002021f          AND      r2,r2,#0x1f
;;;1357     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000018  2301              MOVS     r3,#1
00001a  4093              LSLS     r3,r3,r2
00001c  420b              TST      r3,r1
00001e  d000              BEQ      |L14.34|
;;;1358     {
;;;1359       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L14.34|
;;;1360     }
;;;1361     else
;;;1362     {
;;;1363       bitstatus = RESET;
;;;1364     }
;;;1365   
;;;1366     /* Return the flag status */
;;;1367     return bitstatus;
;;;1368   }
000022  4770              BX       lr
                  |L14.36|
000024  6809              LDR      r1,[r1,#0]            ;1344
000026  e7f5              B        |L14.20|
                  |L14.40|
000028  6a09              LDR      r1,[r1,#0x20]         ;1348
00002a  e7f3              B        |L14.20|
;;;1369   
                          ENDP

                  |L14.44|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1407     */
;;;1408   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L15.16|
;;;1409   {
000002  4601              MOV      r1,r0
;;;1410     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1413   
;;;1414     /* Check the status of the specified RCC interrupt */
;;;1415     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L15.14|
;;;1416     {
;;;1417       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L15.14|
;;;1418     }
;;;1419     else
;;;1420     {
;;;1421       bitstatus = RESET;
;;;1422     }
;;;1423   
;;;1424     /* Return the RCC_IT status */
;;;1425     return  bitstatus;
;;;1426   }
00000e  4770              BX       lr
;;;1427   
                          ENDP

                  |L15.16|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;592      */
;;;593    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;594    {
;;;595      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;596    }
000008  4770              BX       lr
;;;597    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;613      */
;;;614    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L17.16|
;;;615    {
;;;616      uint32_t tmpreg = 0;
;;;617      /* Check the parameters */
;;;618      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;619      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;620      /* Clear HPRE[3:0] bits */
;;;621      tmpreg &= CFGR_HPRE_Reset_Mask;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;622      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;623      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;624      /* Store the new value */
;;;625      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;626    }
00000c  4770              BX       lr
;;;627    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;275      */
;;;276    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  490b              LDR      r1,|L18.48|
;;;277    {
;;;278      /* Check the parameters */
;;;279      assert_param(IS_RCC_HSE(RCC_HSE));
;;;280      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;281      /* Reset HSEON bit */
;;;282      RCC->CR &= CR_HSEON_Reset;
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;283      /* Reset HSEBYP bit */
;;;284      RCC->CR &= CR_HSEBYP_Reset;
00000a  680a              LDR      r2,[r1,#0]
00000c  f4222280          BIC      r2,r2,#0x40000
000010  600a              STR      r2,[r1,#0]
;;;285      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;286      switch(RCC_HSE)
000012  f5b03f80          CMP      r0,#0x10000
000016  d007              BEQ      |L18.40|
000018  f5b02f80          CMP      r0,#0x40000
00001c  d103              BNE      |L18.38|
;;;287      {
;;;288        case RCC_HSE_ON:
;;;289          /* Set HSEON bit */
;;;290          RCC->CR |= CR_HSEON_Set;
;;;291          break;
;;;292          
;;;293        case RCC_HSE_Bypass:
;;;294          /* Set HSEBYP and HSEON bits */
;;;295          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
00001e  6808              LDR      r0,[r1,#0]
000020  f44020a0          ORR      r0,r0,#0x50000
                  |L18.36|
000024  6008              STR      r0,[r1,#0]
                  |L18.38|
;;;296          break;
;;;297          
;;;298        default:
;;;299          break;
;;;300      }
;;;301    }
000026  4770              BX       lr
                  |L18.40|
000028  6808              LDR      r0,[r1,#0]            ;290
00002a  f4403080          ORR      r0,r0,#0x10000        ;290
00002e  e7f9              B        |L18.36|
;;;302    
                          ENDP

                  |L18.48|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;359      */
;;;360    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;364      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;365    }
000004  4770              BX       lr
;;;366    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;705      */
;;;706    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L20.20|
;;;707    {
;;;708      /* Check the parameters */
;;;709      assert_param(IS_RCC_IT(RCC_IT));
;;;710      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;711      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;712      {
;;;713        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;714        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;715      }
;;;716      else
;;;717      {
;;;718        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;719        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7a51              LDRB     r1,[r2,#9]
000006  d001              BEQ      |L20.12|
000008  4301              ORRS     r1,r1,r0              ;714
00000a  e000              B        |L20.14|
                  |L20.12|
00000c  4381              BICS     r1,r1,r0
                  |L20.14|
00000e  7251              STRB     r1,[r2,#9]            ;714
;;;720      }
;;;721    }
000010  4770              BX       lr
;;;722    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;834      */
;;;835    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4906              LDR      r1,|L21.28|
;;;836    {
;;;837      /* Check the parameters */
;;;838      assert_param(IS_RCC_LSE(RCC_LSE));
;;;839      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;840      /* Reset LSEON bit */
;;;841      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  f8812020          STRB     r2,[r1,#0x20]
;;;842      /* Reset LSEBYP bit */
;;;843      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000008  f8812020          STRB     r2,[r1,#0x20]
;;;844      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;845      switch(RCC_LSE)
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L21.22|
000010  2804              CMP      r0,#4
000012  d102              BNE      |L21.26|
;;;846      {
;;;847        case RCC_LSE_ON:
;;;848          /* Set LSEON bit */
;;;849          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;850          break;
;;;851          
;;;852        case RCC_LSE_Bypass:
;;;853          /* Set LSEBYP and LSEON bits */
;;;854          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000014  2005              MOVS     r0,#5
                  |L21.22|
000016  f8810020          STRB     r0,[r1,#0x20]
                  |L21.26|
;;;855          break;            
;;;856          
;;;857        default:
;;;858          break;      
;;;859      }
;;;860    }
00001a  4770              BX       lr
;;;861    
                          ENDP

                  |L21.28|
                          DCD      0x40021000

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;867      */
;;;868    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;869    {
;;;870      /* Check the parameters */
;;;871      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;872      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;873    }
000004  4770              BX       lr
;;;874    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;1287     */
;;;1288   void RCC_MCOConfig(uint8_t RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;1289   {
;;;1290     /* Check the parameters */
;;;1291     assert_param(IS_RCC_MCO(RCC_MCO));
;;;1292   
;;;1293     /* Perform Byte access to MCO bits to select the MCO source */
;;;1294     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;1295   }
000004  4770              BX       lr
;;;1296   
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;639      */
;;;640    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L24.16|
;;;641    {
;;;642      uint32_t tmpreg = 0;
;;;643      /* Check the parameters */
;;;644      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;645      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;646      /* Clear PPRE1[2:0] bits */
;;;647      tmpreg &= CFGR_PPRE1_Reset_Mask;
000004  f42161e0          BIC      r1,r1,#0x700
;;;648      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;649      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;650      /* Store the new value */
;;;651      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;652    }
00000c  4770              BX       lr
;;;653    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;665      */
;;;666    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L25.16|
;;;667    {
;;;668      uint32_t tmpreg = 0;
;;;669      /* Check the parameters */
;;;670      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;671      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;672      /* Clear PPRE2[2:0] bits */
;;;673      tmpreg &= CFGR_PPRE2_Reset_Mask;
000004  f4225260          BIC      r2,r2,#0x3800
;;;674      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;675      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;676      /* Store the new value */
;;;677      RCC->CFGR = tmpreg;
00000c  6048              STR      r0,[r1,#4]
;;;678    }
00000e  4770              BX       lr
;;;679    
                          ENDP

                  |L25.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;406      */
;;;407    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;408    {
;;;409      /* Check the parameters */
;;;410      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;411    
;;;412      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;413    }
000004  4770              BX       lr
;;;414    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;383      */
;;;384    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4a03              LDR      r2,|L27.16|
;;;385    {
;;;386      uint32_t tmpreg = 0;
;;;387    
;;;388      /* Check the parameters */
;;;389      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;390      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;391    
;;;392      tmpreg = RCC->CFGR;
000002  6853              LDR      r3,[r2,#4]
;;;393      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;394      tmpreg &= CFGR_PLL_Mask;
;;;395      /* Set the PLL configuration bits */
;;;396      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000004  4308              ORRS     r0,r0,r1
000006  f423137c          BIC      r3,r3,#0x3f0000       ;394
00000a  4318              ORRS     r0,r0,r3
;;;397      /* Store the new value */
;;;398      RCC->CFGR = tmpreg;
00000c  6050              STR      r0,[r2,#4]
;;;399    }
00000e  4770              BX       lr
;;;400    
                          ENDP

                  |L27.16|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;898      */
;;;899    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;900    {
;;;901      /* Check the parameters */
;;;902      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;903      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;904    }
000004  4770              BX       lr
;;;905    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;884      */
;;;885    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;886    {
;;;887      /* Check the parameters */
;;;888      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;889      /* Select the RTC clock source */
;;;890      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4302              ORRS     r2,r2,r0
000006  620a              STR      r2,[r1,#0x20]
;;;891    }
000008  4770              BX       lr
;;;892    
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;569      */
;;;570    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L30.16|
;;;571    {
;;;572      uint32_t tmpreg = 0;
;;;573      /* Check the parameters */
;;;574      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;575      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;576      /* Clear SW[1:0] bits */
;;;577      tmpreg &= CFGR_SW_Mask;
000004  f0210103          BIC      r1,r1,#3
;;;578      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;579      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;580      /* Store the new value */
;;;581      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;582    }
00000c  4770              BX       lr
;;;583    
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;733      */
;;;734    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;735    {
;;;736      /* Check the parameters */
;;;737      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;738    
;;;739      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  f8c100d8          STR      r0,[r1,#0xd8]
;;;740    }
000006  4770              BX       lr
;;;741    #else
                          ENDP

                  |L31.8|
                          DCD      0x42420000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;309      */
;;;310    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b518              PUSH     {r3,r4,lr}
;;;311    {
;;;312      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
;;;313      ErrorStatus status = ERROR;
;;;314      FlagStatus HSEStatus = RESET;
;;;315      
;;;316      /* Wait till HSE is ready and if Time out is reached exit */
;;;317      do
;;;318      {
;;;319        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;320        StartUpCounter++;  
;;;321      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
000004  f44f64a0          MOV      r4,#0x500
000008  9000              STR      r0,[sp,#0]
                  |L32.10|
00000a  2031              MOVS     r0,#0x31              ;319
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;320
000012  1c49              ADDS     r1,r1,#1              ;320
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L32.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L32.10|
                  |L32.30|
;;;322      
;;;323      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2031              MOVS     r0,#0x31
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L32.42|
;;;324      {
;;;325        status = SUCCESS;
000028  2001              MOVS     r0,#1
                  |L32.42|
;;;326      }
;;;327      else
;;;328      {
;;;329        status = ERROR;
;;;330      }  
;;;331      return (status);
;;;332    }
00002a  bd18              POP      {r3,r4,pc}
;;;333    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REV16|
#line 129 "D:\\Keil5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REVSH|
#line 144
|__asm___15_stm32f10x_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
