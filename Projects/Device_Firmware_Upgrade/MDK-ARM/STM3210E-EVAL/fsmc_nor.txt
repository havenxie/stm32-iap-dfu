; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\fsmc_nor.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\fsmc_nor.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\CMSIS\Include -ID:\Keil5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\fsmc_nor.crf ..\src\fsmc_nor.c]
                          THUMB

                          AREA ||i.FSMC_NOR_EraseBlock||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_EraseBlock PROC
;;;160    *******************************************************************************/
;;;161    NOR_Status FSMC_NOR_EraseBlock(uint32_t BlockAddr)
000000  4909              LDR      r1,|L1.40|
;;;162    {
000002  b430              PUSH     {r4,r5}
;;;163      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  22aa              MOVS     r2,#0xaa
000006  800a              STRH     r2,[r1,#0]
;;;164      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4c08              LDR      r4,|L1.44|
00000a  2355              MOVS     r3,#0x55
00000c  8023              STRH     r3,[r4,#0]
;;;165      NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
00000e  2580              MOVS     r5,#0x80
000010  800d              STRH     r5,[r1,#0]
;;;166      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000012  800a              STRH     r2,[r1,#0]
;;;167      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000014  8023              STRH     r3,[r4,#0]
;;;168      NOR_WRITE((Bank1_NOR2_ADDR + BlockAddr), 0x30);
000016  f10040c8          ADD      r0,r0,#0x64000000
00001a  2130              MOVS     r1,#0x30
00001c  8001              STRH     r1,[r0,#0]
;;;169    
;;;170      return (FSMC_NOR_GetStatus(BlockErase_Timeout));
00001e  bc30              POP      {r4,r5}
000020  f44f0020          MOV      r0,#0xa00000
000024  f7ffbffe          B.W      FSMC_NOR_GetStatus
;;;171    }
;;;172    
                          ENDP

                  |L1.40|
                          DCD      0x64000aaa
                  |L1.44|
                          DCD      0x64000554

                          AREA ||i.FSMC_NOR_EraseChip||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_EraseChip PROC
;;;180    *******************************************************************************/
;;;181    NOR_Status FSMC_NOR_EraseChip(void)
000000  4808              LDR      r0,|L2.36|
;;;182    {
000002  b430              PUSH     {r4,r5}
;;;183      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  21aa              MOVS     r1,#0xaa
000006  8001              STRH     r1,[r0,#0]
;;;184      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4a07              LDR      r2,|L2.40|
00000a  2355              MOVS     r3,#0x55
00000c  8013              STRH     r3,[r2,#0]
;;;185      NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
00000e  2480              MOVS     r4,#0x80
000010  8004              STRH     r4,[r0,#0]
;;;186      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000012  8001              STRH     r1,[r0,#0]
;;;187      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000014  8013              STRH     r3,[r2,#0]
;;;188      NOR_WRITE(ADDR_SHIFT(0x0555), 0x0010);
000016  2110              MOVS     r1,#0x10
000018  8001              STRH     r1,[r0,#0]
;;;189    
;;;190      return (FSMC_NOR_GetStatus(ChipErase_Timeout));
00001a  bc30              POP      {r4,r5}
00001c  f04f5040          MOV      r0,#0x30000000
000020  f7ffbffe          B.W      FSMC_NOR_GetStatus
;;;191    }
;;;192    
                          ENDP

                  |L2.36|
                          DCD      0x64000aaa
                  |L2.40|
                          DCD      0x64000554

                          AREA ||i.FSMC_NOR_GetStatus||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_GetStatus PROC
;;;365    *******************************************************************************/
;;;366    NOR_Status FSMC_NOR_GetStatus(uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;367    { 
000002  4604              MOV      r4,r0
;;;368      uint16_t val1 = 0x00, val2 = 0x00;
;;;369      NOR_Status status = NOR_ONGOING; 
;;;370      uint32_t timeout = Timeout;
000004  4605              MOV      r5,r0
;;;371    
;;;372      /* Poll on NOR memory Ready/Busy signal ------------------------------------*/
;;;373      while((GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_6) != RESET) && (timeout > 0)) 
000006  4e18              LDR      r6,|L3.104|
000008  e000              B        |L3.12|
                  |L3.10|
00000a  1e6d              SUBS     r5,r5,#1              ;367
                  |L3.12|
00000c  2140              MOVS     r1,#0x40
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       GPIO_ReadInputDataBit
000014  b108              CBZ      r0,|L3.26|
000016  2d00              CMP      r5,#0
000018  d1f7              BNE      |L3.10|
                  |L3.26|
;;;374      {
;;;375        timeout--;
;;;376      }
;;;377    
;;;378      timeout = Timeout;
00001a  4625              MOV      r5,r4
;;;379      
;;;380      while((GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_6) == RESET) && (timeout > 0))   
00001c  e000              B        |L3.32|
                  |L3.30|
00001e  1e6d              SUBS     r5,r5,#1
                  |L3.32|
000020  2140              MOVS     r1,#0x40
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       GPIO_ReadInputDataBit
000028  b908              CBNZ     r0,|L3.46|
00002a  2d00              CMP      r5,#0
00002c  d1f7              BNE      |L3.30|
                  |L3.46|
;;;381      {
;;;382        timeout--;
;;;383      }
;;;384      
;;;385      /* Get the NOR memory operation status -------------------------------------*/
;;;386      while((Timeout != 0x00) && (status != NOR_SUCCESS))
;;;387      {
;;;388        Timeout--;
;;;389    
;;;390    	  /* Read DQ6 and DQ5 */
;;;391        val1 = *(__IO uint16_t *)(Bank1_NOR2_ADDR);
;;;392        val2 = *(__IO uint16_t *)(Bank1_NOR2_ADDR);
;;;393    
;;;394        /* If DQ6 did not toggle between the two reads then return NOR_Success */
;;;395        if((val1 & 0x0040) == (val2 & 0x0040)) 
;;;396        {
;;;397          return NOR_SUCCESS;
;;;398        }
;;;399    
;;;400        if((val1 & 0x0020) != 0x0020)
;;;401        {
;;;402          status = NOR_ONGOING;
;;;403        }
;;;404    
;;;405        val1 = *(__IO uint16_t *)(Bank1_NOR2_ADDR);
00002e  f04f41c8          MOV      r1,#0x64000000
                  |L3.50|
000032  b1b4              CBZ      r4,|L3.98|
000034  8808              LDRH     r0,[r1,#0]            ;391
000036  880a              LDRH     r2,[r1,#0]            ;392
000038  f0000040          AND      r0,r0,#0x40           ;395
00003c  f0020240          AND      r2,r2,#0x40           ;395
000040  1e64              SUBS     r4,r4,#1              ;395
000042  4290              CMP      r0,r2                 ;395
000044  d007              BEQ      |L3.86|
000046  8808              LDRH     r0,[r1,#0]
;;;406        val2 = *(__IO uint16_t *)(Bank1_NOR2_ADDR);
000048  880a              LDRH     r2,[r1,#0]
;;;407        
;;;408        if((val1 & 0x0040) == (val2 & 0x0040)) 
00004a  f0000340          AND      r3,r0,#0x40
00004e  f0020240          AND      r2,r2,#0x40
000052  4293              CMP      r3,r2
000054  d101              BNE      |L3.90|
                  |L3.86|
;;;409        {
;;;410          return NOR_SUCCESS;
000056  2000              MOVS     r0,#0
;;;411        }
;;;412        else if((val1 & 0x0020) == 0x0020)
;;;413        {
;;;414          return NOR_ERROR;
;;;415        }
;;;416      }
;;;417    
;;;418      if(Timeout == 0x00)
;;;419      {
;;;420        status = NOR_TIMEOUT;
;;;421      } 
;;;422    
;;;423      /* Return the operation status */
;;;424      return (status);
;;;425    }
000058  bd70              POP      {r4-r6,pc}
                  |L3.90|
00005a  0680              LSLS     r0,r0,#26             ;412
00005c  d5e9              BPL      |L3.50|
00005e  2002              MOVS     r0,#2                 ;414
000060  bd70              POP      {r4-r6,pc}
                  |L3.98|
000062  2003              MOVS     r0,#3                 ;420
000064  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      0x40011400

                          AREA ||i.FSMC_NOR_Init||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_Init PROC
;;;56     *******************************************************************************/
;;;57     void FSMC_NOR_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  b098              SUB      sp,sp,#0x60
;;;59       FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;60       FSMC_NORSRAMTimingInitTypeDef  p;
;;;61       GPIO_InitTypeDef GPIO_InitStructure;
;;;62     
;;;63       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | 
000004  2101              MOVS     r1,#1
000006  f44f70f0          MOV      r0,#0x1e0
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;64                              RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG, ENABLE);
;;;65     
;;;66       /*-- GPIO Configuration ------------------------------------------------------*/
;;;67       /* NOR Data lines configuration */
;;;68       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | GPIO_Pin_9 |
00000e  f24c7003          MOV      r0,#0xc703
000012  f8ad0058          STRH     r0,[sp,#0x58]
;;;69                                     GPIO_Pin_10 | GPIO_Pin_14 | GPIO_Pin_15;
;;;70       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000016  2018              MOVS     r0,#0x18
000018  f88d005b          STRB     r0,[sp,#0x5b]
;;;71       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
;;;72       GPIO_Init(GPIOD, &GPIO_InitStructure);
00001e  4c31              LDR      r4,|L4.228|
000020  f88d005a          STRB     r0,[sp,#0x5a]         ;71
000024  a916              ADD      r1,sp,#0x58
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_Init
;;;73     
;;;74       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
00002c  f64f7080          MOV      r0,#0xff80
;;;75                                     GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 |
;;;76                                     GPIO_Pin_14 | GPIO_Pin_15;
;;;77       GPIO_Init(GPIOE, &GPIO_InitStructure);
000030  4d2d              LDR      r5,|L4.232|
000032  f8ad0058          STRH     r0,[sp,#0x58]         ;74
000036  a916              ADD      r1,sp,#0x58
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_Init
;;;78     
;;;79       /* NOR Address lines configuration */
;;;80       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |
00003e  f24f003f          MOV      r0,#0xf03f
000042  f8ad0058          STRH     r0,[sp,#0x58]
;;;81                                     GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_12 | GPIO_Pin_13 |
;;;82                                     GPIO_Pin_14 | GPIO_Pin_15;
;;;83       GPIO_Init(GPIOF, &GPIO_InitStructure);
000046  a916              ADD      r1,sp,#0x58
000048  4828              LDR      r0,|L4.236|
00004a  f7fffffe          BL       GPIO_Init
;;;84     
;;;85       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 |
00004e  203f              MOVS     r0,#0x3f
;;;86                                     GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;                            
;;;87       GPIO_Init(GPIOG, &GPIO_InitStructure);
000050  4e27              LDR      r6,|L4.240|
000052  f8ad0058          STRH     r0,[sp,#0x58]         ;85
000056  a916              ADD      r1,sp,#0x58
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       GPIO_Init
;;;88     
;;;89       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
00005e  f44f5060          MOV      r0,#0x3800
000062  f8ad0058          STRH     r0,[sp,#0x58]
;;;90       GPIO_Init(GPIOD, &GPIO_InitStructure);
000066  a916              ADD      r1,sp,#0x58
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       GPIO_Init
;;;91     
;;;92       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;
00006e  2078              MOVS     r0,#0x78
000070  f8ad0058          STRH     r0,[sp,#0x58]
;;;93       GPIO_Init(GPIOE, &GPIO_InitStructure);
000074  a916              ADD      r1,sp,#0x58
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       GPIO_Init
;;;94     
;;;95       /* NOE and NWE configuration */
;;;96       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;
00007c  2030              MOVS     r0,#0x30
00007e  f8ad0058          STRH     r0,[sp,#0x58]
;;;97       GPIO_Init(GPIOD, &GPIO_InitStructure);
000082  a916              ADD      r1,sp,#0x58
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       GPIO_Init
;;;98     
;;;99       /* NE2 configuration */
;;;100      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00008a  1560              ASRS     r0,r4,#21
00008c  f8ad0058          STRH     r0,[sp,#0x58]
;;;101      GPIO_Init(GPIOG, &GPIO_InitStructure);
000090  a916              ADD      r1,sp,#0x58
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       GPIO_Init
;;;102    
;;;103      /*-- FSMC Configuration ----------------------------------------------------*/
;;;104      p.FSMC_AddressSetupTime = 0x02;
000098  2102              MOVS     r1,#2
;;;105      p.FSMC_AddressHoldTime = 0x00;
00009a  2000              MOVS     r0,#0
;;;106      p.FSMC_DataSetupTime = 0x05;
00009c  e9cd100f          STRD     r1,r0,[sp,#0x3c]
0000a0  2205              MOVS     r2,#5
0000a2  e9cd2011          STRD     r2,r0,[sp,#0x44]
;;;107      p.FSMC_BusTurnAroundDuration = 0x00;
;;;108      p.FSMC_CLKDivision = 0x00;
;;;109      p.FSMC_DataLatency = 0x00;
;;;110      p.FSMC_AccessMode = FSMC_AccessMode_B;
0000a6  06ca              LSLS     r2,r1,#27
0000a8  e9cd0214          STRD     r0,r2,[sp,#0x50]
0000ac  e9cd1000          STRD     r1,r0,[sp,#0]
;;;111    
;;;112      FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;
;;;113      FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;114      FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_NOR;
0000b0  2108              MOVS     r1,#8
;;;115      FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
0000b2  9102              STR      r1,[sp,#8]
0000b4  9013              STR      r0,[sp,#0x4c]         ;110
0000b6  2110              MOVS     r1,#0x10
0000b8  e9cd1003          STRD     r1,r0,[sp,#0xc]
;;;116      FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;117      FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
;;;118      FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
0000bc  9006              STR      r0,[sp,#0x18]
;;;119      FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;120      FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
0000be  0209              LSLS     r1,r1,#8
0000c0  9007              STR      r0,[sp,#0x1c]
0000c2  e9cd0108          STRD     r0,r1,[sp,#0x20]
;;;121      FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;122      FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
0000c6  900a              STR      r0,[sp,#0x28]
;;;123      FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
0000c8  900b              STR      r0,[sp,#0x2c]
;;;124      FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
0000ca  900c              STR      r0,[sp,#0x30]
0000cc  a80f              ADD      r0,sp,#0x3c
;;;125      FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
0000ce  900d              STR      r0,[sp,#0x34]
;;;126    
;;;127      FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
0000d0  900e              STR      r0,[sp,#0x38]
0000d2  4668              MOV      r0,sp
0000d4  f7fffffe          BL       FSMC_NORSRAMInit
;;;128    
;;;129      /* Enable FSMC Bank1_NOR Bank */
;;;130      FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);
0000d8  2101              MOVS     r1,#1
0000da  2002              MOVS     r0,#2
0000dc  f7fffffe          BL       FSMC_NORSRAMCmd
;;;131    }
0000e0  b018              ADD      sp,sp,#0x60
0000e2  bd70              POP      {r4-r6,pc}
;;;132    
                          ENDP

                  |L4.228|
                          DCD      0x40011400
                  |L4.232|
                          DCD      0x40011800
                  |L4.236|
                          DCD      0x40011c00
                  |L4.240|
                          DCD      0x40012000

                          AREA ||i.FSMC_NOR_ProgramBuffer||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_ProgramBuffer PROC
;;;251    *******************************************************************************/
;;;252    NOR_Status FSMC_NOR_ProgramBuffer(uint16_t* pBuffer, uint32_t WriteAddr, uint32_t NumHalfwordToWrite)
000000  b4f0              PUSH     {r4-r7}
;;;253    {       
;;;254      uint32_t lastloadedaddress = 0x00;
;;;255      uint32_t currentaddress = 0x00;
;;;256      uint32_t endaddress = 0x00;
;;;257    
;;;258      /* Initialize variables */
;;;259      currentaddress = WriteAddr;
;;;260      endaddress = WriteAddr + NumHalfwordToWrite - 1;
;;;261      lastloadedaddress = WriteAddr;
;;;262    
;;;263      /* Issue unlock command sequence */
;;;264      NOR_WRITE(ADDR_SHIFT(0x00555), 0x00AA);
000002  4e12              LDR      r6,|L5.76|
000004  188c              ADDS     r4,r1,r2              ;260
000006  25aa              MOVS     r5,#0xaa
000008  460b              MOV      r3,r1                 ;261
00000a  8035              STRH     r5,[r6,#0]
;;;265    
;;;266      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);  
00000c  4e10              LDR      r6,|L5.80|
00000e  2555              MOVS     r5,#0x55
000010  8035              STRH     r5,[r6,#0]
;;;267    
;;;268      /* Write Write Buffer Load Command */
;;;269      NOR_WRITE(ADDR_SHIFT(WriteAddr), 0x0025);
000012  2625              MOVS     r6,#0x25
000014  004d              LSLS     r5,r1,#1
000016  f10545c8          ADD      r5,r5,#0x64000000
00001a  802e              STRH     r6,[r5,#0]
00001c  1e52              SUBS     r2,r2,#1
;;;270      NOR_WRITE(ADDR_SHIFT(WriteAddr), (NumHalfwordToWrite - 1));
00001e  802a              STRH     r2,[r5,#0]
000020  1e64              SUBS     r4,r4,#1
000022  e007              B        |L5.52|
                  |L5.36|
;;;271    
;;;272      /* Load Data into NOR Buffer */
;;;273      while(currentaddress <= endaddress)
;;;274      {
;;;275        /* Store last loaded address & data value (for polling) */
;;;276        lastloadedaddress = currentaddress;
;;;277     
;;;278        NOR_WRITE(ADDR_SHIFT(currentaddress), *pBuffer++);
000024  004a              LSLS     r2,r1,#1
000026  f10242c8          ADD      r2,r2,#0x64000000
00002a  f8305b02          LDRH     r5,[r0],#2
00002e  460b              MOV      r3,r1                 ;276
000030  8015              STRH     r5,[r2,#0]
;;;279        currentaddress += 1; 
000032  1c49              ADDS     r1,r1,#1
                  |L5.52|
000034  42a1              CMP      r1,r4                 ;273
000036  d9f5              BLS      |L5.36|
;;;280      }
;;;281    
;;;282      NOR_WRITE(ADDR_SHIFT(lastloadedaddress), 0x29);
000038  2129              MOVS     r1,#0x29
00003a  0058              LSLS     r0,r3,#1
00003c  f10040c8          ADD      r0,r0,#0x64000000
000040  8001              STRH     r1,[r0,#0]
;;;283      
;;;284      return(FSMC_NOR_GetStatus(Program_Timeout));
000042  bcf0              POP      {r4-r7}
000044  f44f50a0          MOV      r0,#0x1400
000048  f7ffbffe          B.W      FSMC_NOR_GetStatus
;;;285    }
;;;286    
                          ENDP

                  |L5.76|
                          DCD      0x64000aaa
                  |L5.80|
                          DCD      0x64000554

                          AREA ||i.FSMC_NOR_ReadBuffer||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_ReadBuffer PROC
;;;312    *******************************************************************************/
;;;313    void FSMC_NOR_ReadBuffer(uint16_t* pBuffer, uint32_t ReadAddr, uint32_t NumHalfwordToRead)
000000  b510              PUSH     {r4,lr}
;;;314    {
;;;315      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000002  4c0b              LDR      r4,|L6.48|
000004  23aa              MOVS     r3,#0xaa
000006  8023              STRH     r3,[r4,#0]
;;;316      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4c0a              LDR      r4,|L6.52|
00000a  2355              MOVS     r3,#0x55
00000c  8023              STRH     r3,[r4,#0]
;;;317      NOR_WRITE((Bank1_NOR2_ADDR + ReadAddr), 0x00F0);
00000e  24f0              MOVS     r4,#0xf0
000010  f04f43c8          MOV      r3,#0x64000000
000014  2a00              CMP      r2,#0                 ;314
000016  525c              STRH     r4,[r3,r1]
000018  d008              BEQ      |L6.44|
;;;318    
;;;319      for(; NumHalfwordToRead != 0x00; NumHalfwordToRead--) /* while there is data to read */
;;;320      {
;;;321        /* Read a Halfword from the NOR */
;;;322        *pBuffer++ = *(__IO uint16_t *)((Bank1_NOR2_ADDR + ReadAddr));
00001a  bf00              NOP      
                  |L6.28|
00001c  f04f43c8          MOV      r3,#0x64000000
000020  5a5b              LDRH     r3,[r3,r1]
000022  1c89              ADDS     r1,r1,#2
000024  f8203b02          STRH     r3,[r0],#2
000028  1e52              SUBS     r2,r2,#1
00002a  d1f7              BNE      |L6.28|
                  |L6.44|
;;;323        ReadAddr = ReadAddr + 2; 
;;;324      }  
;;;325    }
00002c  bd10              POP      {r4,pc}
;;;326    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x64000aaa
                  |L6.52|
                          DCD      0x64000554

                          AREA ||i.FSMC_NOR_ReadHalfWord||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_ReadHalfWord PROC
;;;293    *******************************************************************************/
;;;294    uint16_t FSMC_NOR_ReadHalfWord(uint32_t ReadAddr)
000000  4a05              LDR      r2,|L7.24|
;;;295    {
;;;296      NOR_WRITE(ADDR_SHIFT(0x00555), 0x00AA); 
000002  21aa              MOVS     r1,#0xaa
000004  8011              STRH     r1,[r2,#0]
;;;297      NOR_WRITE(ADDR_SHIFT(0x002AA), 0x0055);  
000006  4a05              LDR      r2,|L7.28|
000008  2155              MOVS     r1,#0x55
00000a  8011              STRH     r1,[r2,#0]
;;;298      NOR_WRITE((Bank1_NOR2_ADDR + ReadAddr), 0x00F0 );
00000c  f10040c8          ADD      r0,r0,#0x64000000
000010  21f0              MOVS     r1,#0xf0
000012  8001              STRH     r1,[r0,#0]
;;;299    
;;;300      return (*(__IO uint16_t *)((Bank1_NOR2_ADDR + ReadAddr)));
000014  8800              LDRH     r0,[r0,#0]
;;;301    }
000016  4770              BX       lr
;;;302    
                          ENDP

                  |L7.24|
                          DCD      0x64000aaa
                  |L7.28|
                          DCD      0x64000554

                          AREA ||i.FSMC_NOR_ReadID||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_ReadID PROC
;;;140    *******************************************************************************/
;;;141    void FSMC_NOR_ReadID(NOR_IDTypeDef* NOR_ID)
000000  4909              LDR      r1,|L8.40|
;;;142    {
;;;143      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000002  22aa              MOVS     r2,#0xaa
000004  800a              STRH     r2,[r1,#0]
;;;144      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000006  4b09              LDR      r3,|L8.44|
000008  2255              MOVS     r2,#0x55
00000a  801a              STRH     r2,[r3,#0]
;;;145      NOR_WRITE(ADDR_SHIFT(0x0555), 0x0090);
00000c  2290              MOVS     r2,#0x90
00000e  800a              STRH     r2,[r1,#0]
;;;146    
;;;147      NOR_ID->Manufacturer_Code = *(__IO uint16_t *) ADDR_SHIFT(0x0000);
000010  f04f41c8          MOV      r1,#0x64000000
000014  880a              LDRH     r2,[r1,#0]
000016  8002              STRH     r2,[r0,#0]
;;;148      NOR_ID->Device_Code1 = *(__IO uint16_t *) ADDR_SHIFT(0x0001);
000018  884a              LDRH     r2,[r1,#2]
00001a  8042              STRH     r2,[r0,#2]
;;;149      NOR_ID->Device_Code2 = *(__IO uint16_t *) ADDR_SHIFT(0x000E);
00001c  8b8a              LDRH     r2,[r1,#0x1c]
00001e  8082              STRH     r2,[r0,#4]
;;;150      NOR_ID->Device_Code3 = *(__IO uint16_t *) ADDR_SHIFT(0x000F);
000020  8bc9              LDRH     r1,[r1,#0x1e]
000022  80c1              STRH     r1,[r0,#6]
;;;151    }
000024  4770              BX       lr
;;;152    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x64000aaa
                  |L8.44|
                          DCD      0x64000554

                          AREA ||i.FSMC_NOR_Reset||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_Reset PROC
;;;348    *******************************************************************************/
;;;349    NOR_Status FSMC_NOR_Reset(void)
000000  4905              LDR      r1,|L9.24|
;;;350    {
;;;351      NOR_WRITE(ADDR_SHIFT(0x00555), 0x00AA); 
000002  20aa              MOVS     r0,#0xaa
000004  8008              STRH     r0,[r1,#0]
;;;352      NOR_WRITE(ADDR_SHIFT(0x002AA), 0x0055); 
000006  4905              LDR      r1,|L9.28|
000008  2055              MOVS     r0,#0x55
00000a  8008              STRH     r0,[r1,#0]
;;;353      NOR_WRITE(Bank1_NOR2_ADDR, 0x00F0); 
00000c  f04f41c8          MOV      r1,#0x64000000
000010  20f0              MOVS     r0,#0xf0
000012  8008              STRH     r0,[r1,#0]
;;;354    
;;;355      return (NOR_SUCCESS);
000014  2000              MOVS     r0,#0
;;;356    }
000016  4770              BX       lr
;;;357    
                          ENDP

                  |L9.24|
                          DCD      0x64000aaa
                  |L9.28|
                          DCD      0x64000554

                          AREA ||i.FSMC_NOR_ReturnToReadMode||, CODE, READONLY, ALIGN=1

                  FSMC_NOR_ReturnToReadMode PROC
;;;333    *******************************************************************************/
;;;334    NOR_Status FSMC_NOR_ReturnToReadMode(void)
000000  f04f41c8          MOV      r1,#0x64000000
;;;335    {
;;;336      NOR_WRITE(Bank1_NOR2_ADDR, 0x00F0);
000004  20f0              MOVS     r0,#0xf0
000006  8008              STRH     r0,[r1,#0]
;;;337    
;;;338      return (NOR_SUCCESS);
000008  2000              MOVS     r0,#0
;;;339    }
00000a  4770              BX       lr
;;;340    
                          ENDP


                          AREA ||i.FSMC_NOR_WriteBuffer||, CODE, READONLY, ALIGN=1

                  FSMC_NOR_WriteBuffer PROC
;;;222    *******************************************************************************/
;;;223    NOR_Status FSMC_NOR_WriteBuffer(uint16_t* pBuffer, uint32_t WriteAddr, uint32_t NumHalfwordToWrite)
000000  b570              PUSH     {r4-r6,lr}
;;;224    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
                  |L11.8|
;;;225      NOR_Status status = NOR_ONGOING; 
;;;226    
;;;227      do
;;;228      {
;;;229        /* Transfer data to the memory */
;;;230        status = FSMC_NOR_WriteHalfWord(WriteAddr, *pBuffer++);
000008  4630              MOV      r0,r6
00000a  f8341b02          LDRH     r1,[r4],#2
00000e  f7fffffe          BL       FSMC_NOR_WriteHalfWord
000012  1e6d              SUBS     r5,r5,#1
000014  1cb6              ADDS     r6,r6,#2
;;;231        WriteAddr = WriteAddr + 2;
;;;232        NumHalfwordToWrite--;
;;;233      }
;;;234      while((status == NOR_SUCCESS) && (NumHalfwordToWrite != 0));
000016  2800              CMP      r0,#0
000018  d101              BNE      |L11.30|
00001a  2d00              CMP      r5,#0
00001c  d1f4              BNE      |L11.8|
                  |L11.30|
;;;235      
;;;236      return (status); 
;;;237    }
00001e  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP


                          AREA ||i.FSMC_NOR_WriteHalfWord||, CODE, READONLY, ALIGN=2

                  FSMC_NOR_WriteHalfWord PROC
;;;201    *******************************************************************************/
;;;202    NOR_Status FSMC_NOR_WriteHalfWord(uint32_t WriteAddr, uint16_t Data)
000000  4a07              LDR      r2,|L12.32|
;;;203    {
000002  b430              PUSH     {r4,r5}
;;;204      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  23aa              MOVS     r3,#0xaa
000006  8013              STRH     r3,[r2,#0]
;;;205      NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4c06              LDR      r4,|L12.36|
00000a  2355              MOVS     r3,#0x55
00000c  8023              STRH     r3,[r4,#0]
;;;206      NOR_WRITE(ADDR_SHIFT(0x0555), 0x00A0);
00000e  23a0              MOVS     r3,#0xa0
000010  8013              STRH     r3,[r2,#0]
000012  f10040c8          ADD      r0,r0,#0x64000000
;;;207      NOR_WRITE((Bank1_NOR2_ADDR + WriteAddr), Data);
000016  8001              STRH     r1,[r0,#0]
;;;208    
;;;209      return (FSMC_NOR_GetStatus(Program_Timeout));
000018  bc30              POP      {r4,r5}
00001a  0158              LSLS     r0,r3,#5
00001c  f7ffbffe          B.W      FSMC_NOR_GetStatus
;;;210    }
;;;211    
                          ENDP

                  |L12.32|
                          DCD      0x64000aaa
                  |L12.36|
                          DCD      0x64000554

;*** Start embedded assembler ***

#line 1 "..\\src\\fsmc_nor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fsmc_nor_c_ae10561b____REV16|
#line 129 "D:\\Keil5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_fsmc_nor_c_ae10561b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fsmc_nor_c_ae10561b____REVSH|
#line 144
|__asm___10_fsmc_nor_c_ae10561b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
